<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How To Mock APIs In Seconds | Norte</title>
<meta name="keywords" content="javascript, tooling, prototyping, mocks">
<meta name="description" content="HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. ">
<meta name="author" content="Shubhendu Madhukar">
<link rel="canonical" href="https://beltebelt.github.io/norte/posts/mock-apis/">
<link crossorigin="anonymous" href="/norte/assets/css/stylesheet.051b4037c3034e1271539824f177e4117bfa178a0a30c710357a19c615d78257.css" integrity="sha256-BRtAN8MDThJxU5gk8XfkEXv6F4oKMMcQNXoZxhXXglc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://beltebelt.github.io/norte/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://beltebelt.github.io/norte/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://beltebelt.github.io/norte/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://beltebelt.github.io/norte/apple-touch-icon.png">
<link rel="mask-icon" href="https://beltebelt.github.io/norte/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://beltebelt.github.io/norte/posts/mock-apis/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://beltebelt.github.io/norte/posts/mock-apis/">
  <meta property="og:site_name" content="Norte">
  <meta property="og:title" content="How To Mock APIs In Seconds">
  <meta property="og:description" content="HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-02-19T00:00:00+00:00">
    <meta property="article:tag" content="Javascript">
    <meta property="article:tag" content="Tooling">
    <meta property="article:tag" content="Prototyping">
    <meta property="article:tag" content="Mocks">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="How To Mock APIs In Seconds">
<meta name="twitter:description" content="HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. ">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://beltebelt.github.io/norte/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How To Mock APIs In Seconds",
      "item": "https://beltebelt.github.io/norte/posts/mock-apis/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How To Mock APIs In Seconds",
  "name": "How To Mock APIs In Seconds",
  "description": "HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. ",
  "keywords": [
    "javascript", "tooling", "prototyping", "mocks"
  ],
  "articleBody": "If you are a part of a testing community in a microservices world, you would often come across challenges in terms of environment availability, resource constraints, clash in release cycles and what not.\nConsider an example where you are testing the application A. During one of your test flows, application A makes a downstream call to application B. And guess what? For one or more of the many reasons, application B is unavailable. You end up waiting for application B even though, it is just a dependency that you are not even testing.\nIn these scenarios, you can use a mock API to act as a stand in for application B and provide application A with dummy responses so that you can continue your tests without any dependency on the downstream.\nWhat are HTTP mocks? HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. Mocks are great for several reasons:\nYou are building a frontend application but your backend isn’t ready yet. Use mocks to quickly create an API which provides you a dummy response and test your frontend application without actually hitting a backend. Once your backend is ready just replace the mock server host with the actual server host in your configs and everything else remains the same. You can have similar use cases while running unit tests, functional tests or even performance tests, where as long as the mock API can simulate the latency and provide a response similar to actual response, you don’t need your complete backend and downstream to be ready for running tests in silos. Mocks are also great for debugging purposes, when you are testing multiple microservices together. Even with advanced monitoring tools, sometimes it’s hard to pinpoint the exact cause of the issue. With mocks you can plug and play and debug which component is causing problems How do you create mocks? While there are a lot many tools available in open source world that allow you to create mocks, in this article I’ll discuss a new tool I have been working on. Camouflage.\nCamouflage works just as the name suggests. It allows you to create and use dummy APIs. And your front end or dependant applications wouldn’t be able to tell the difference if the response is coming from a mock or an actual API.\nThough Camouflage isn’t an original idea (mockserver already implemented something similar), it has a lot of cool features and enhancements over existing tools that help you get up and running within seconds. Few of the prominent features are:\nCamouflage has a near minimum learning curve. Create a directory mocks/hello-world. Place a file named GET.mock containing your raw HTTP Response. And you are done. Make a GET request to /hello-world and you get your expected response. Camouflage heavily uses handlebars, which enables you to add character to your response. Insert dynamic random values that change on each invocation, fetch data from incoming request and send out a conditional response, simulate delays and lot more. Camouflage comes in two modes, functional and performance. By default Camouflage runs in functional mode, which is sufficient for unit tests, frontend testing, even a small scale performance test. However if your machine has multiple CPUs and you are planning to run a performance test, why not make use of the full potential of your machine. You can use performance mode which lets Camouflage utilise multiple CPUs using node’s cluster module. Enough talk. How do we create a mock? Well, you follow five simple steps:\nInstall Camouflage: npm install -g camouflage-server Create a mocks directory which will contain all your mocks. e.g. ~/mocks Start Camouflage: camouflage -m ~/mocks Create another directory in the format your APIs basepath would be. For example: For an API http://localhost:8080/hello/world, create directories as ~/mocks/hello/world Create a file ${HTTP_METHOD}.mock and insert your HTTP raw response. e.g vi ~/mocks/hello/world/GET.mock and paste following content. (If you are on windows, simply use notepad.) HTTP/1.1 200 OK X-Custom-Header: Custom-Value Content-Type: application/json { \"greeting\": \"Hey! It works!\" } And you are done, navigate to http://localhost:8080/hello/world, to see your mock in action.\nConclusion There are already a lot of mocking tools already available like Wiremock, mountebank etc. And those are really great tools, but in my experience, it took me sometime to familiarise myself with the tool, their JSON schema and other available options. The problem statement Camouflage tries to tackle is simple, how to shorten the learning curve and get started with mocks creation within seconds.\nAre you working on prototyping your app? Do you want to starting testing it and you are worried that not all your services are ready? Talk to us about how you can start early testing without waiting for everything to be ready.\n",
  "wordCount" : "792",
  "inLanguage": "en",
  "datePublished": "2025-02-19T00:00:00Z",
  "dateModified": "2025-02-19T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Shubhendu Madhukar"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://beltebelt.github.io/norte/posts/mock-apis/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Norte",
    "logo": {
      "@type": "ImageObject",
      "url": "https://beltebelt.github.io/norte/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://beltebelt.github.io/norte/" accesskey="h" title="Norte (Alt + H)">Norte</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://beltebelt.github.io/norte/why-us/" title="Why Us?">
                    <span>Why Us?</span>
                </a>
            </li>
            <li>
                <a href="https://beltebelt.github.io/norte/contact/" title="Talk To Us">
                    <span>Talk To Us</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      How To Mock APIs In Seconds
    </h1>
    <div class="post-description">
      HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. 
    </div>
    <div class="post-meta"><span title='2025-02-19 00:00:00 +0000 UTC'>February 19, 2025</span>&nbsp;·&nbsp;Shubhendu Madhukar

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-are-http-mocks" aria-label="What are HTTP mocks?">What are HTTP mocks?</a></li>
                <li>
                    <a href="#how-do-you-create-mocks" aria-label="How do you create mocks?">How do you create mocks?</a></li>
                <li>
                    <a href="#enough-talk-how-do-we-create-a-mock" aria-label="Enough talk. How do we create a mock?">Enough talk. How do we create a mock?</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>If you are a part of a testing community in a microservices world, you would often come across challenges in terms of environment availability, resource constraints, clash in release cycles and what not.</p>
<p>Consider an example where you are testing the application A. During one of your test flows, application A makes a downstream call to application B. And guess what? For one or more of the many reasons, application B is unavailable. You end up waiting for application B even though, it is just a dependency that you are not even testing.</p>
<p>In these scenarios, you can use a mock API to act as a stand in for application B and provide application A with dummy responses so that you can continue your tests without any dependency on the downstream.</p>
<h3 id="what-are-http-mocks">What are HTTP mocks?<a hidden class="anchor" aria-hidden="true" href="#what-are-http-mocks">#</a></h3>
<p>HTTP Mocks or Stubs, are replacements for your actual APIs, which can be used for testing purposes. Mocks are great for several reasons:</p>
<ol>
<li>You are building a frontend application but your backend isn&rsquo;t ready yet. Use mocks to quickly create an API which provides you a dummy response and test your frontend application without actually hitting a backend. Once your backend is ready just replace the mock server host with the actual server host in your configs and everything else remains the same.</li>
<li>You can have similar use cases while running unit tests, functional tests or even performance tests, where as long as the mock API can simulate the latency and provide a response similar to actual response, you don&rsquo;t need your complete backend and downstream to be ready for running tests in silos.</li>
<li>Mocks are also great for debugging purposes, when you are testing multiple microservices together. Even with advanced monitoring tools, sometimes it&rsquo;s hard to pinpoint the exact cause of the issue. With mocks you can plug and play and debug which component is causing problems</li>
</ol>
<h3 id="how-do-you-create-mocks">How do you create mocks?<a hidden class="anchor" aria-hidden="true" href="#how-do-you-create-mocks">#</a></h3>
<p>While there are a lot many tools available in open source world that allow you to create mocks, in this article I&rsquo;ll discuss a new tool I have been working on. Camouflage.</p>
<p>Camouflage works just as the name suggests. It allows you to create and use dummy APIs. And your front end or dependant applications wouldn&rsquo;t be able to tell the difference if the response is coming from a mock or an actual API.</p>
<p>Though Camouflage isn&rsquo;t an original idea (mockserver already implemented something similar), it has a lot of cool features and enhancements over existing tools that help you get up and running within seconds. Few of the prominent features are:</p>
<ol>
<li>Camouflage has a near minimum learning curve. Create a directory mocks/hello-world. Place a file named GET.mock containing your raw HTTP Response. And you are done. Make a GET request to /hello-world and you get your expected response.</li>
<li>Camouflage heavily uses handlebars, which enables you to add character to your response. Insert dynamic random values that change on each invocation, fetch data from incoming request and send out a conditional response, simulate delays and lot more.</li>
<li>Camouflage comes in two modes, functional and performance. By default Camouflage runs in functional mode, which is sufficient for unit tests, frontend testing, even a small scale performance test. However if your machine has multiple CPUs and you are planning to run a performance test, why not make use of the full potential of your machine. You can use performance mode which lets Camouflage utilise multiple CPUs using node&rsquo;s cluster module.</li>
</ol>
<h3 id="enough-talk-how-do-we-create-a-mock">Enough talk. How do we create a mock?<a hidden class="anchor" aria-hidden="true" href="#enough-talk-how-do-we-create-a-mock">#</a></h3>
<p>Well, you follow five simple steps:</p>
<ol>
<li>Install Camouflage: <code>npm install -g camouflage-server</code></li>
<li>Create a mocks directory which will contain all your mocks. e.g. <code>~/mocks</code></li>
<li>Start Camouflage: <code>camouflage -m ~/mocks</code></li>
<li>Create another directory in the format your APIs basepath would be. For example: For an API <code>http://localhost:8080/hello/world</code>, create directories as <code>~/mocks/hello/world</code></li>
<li>Create a file ${HTTP_METHOD}.mock and insert your HTTP raw response. e.g <code>vi ~/mocks/hello/world/GET.mock</code> and paste following content. (If you are on windows, simply use notepad.)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#a6e22e">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">200</span> <span style="color:#a6e22e">OK</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">X</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Custom</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Header</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">Custom</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Value</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Content</span><span style="color:#f92672">-</span><span style="color:#a6e22e">Type</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">application</span><span style="color:#f92672">/</span><span style="color:#a6e22e">json</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>     <span style="color:#e6db74">&#34;greeting&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Hey! It works!&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And you are done, navigate to http://localhost:8080/hello/world, to see your mock in action.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>There are already a lot of mocking tools already available like Wiremock, mountebank etc. And those are really great tools, but in my experience, it took me sometime to familiarise myself with the tool, their JSON schema and other available options. The problem statement Camouflage tries to tackle is simple, how to shorten the learning curve and get started with mocks creation within seconds.</p>
<p><strong>Are you working on prototyping your app? Do you want to starting testing it and you are worried that not all your services are ready? <a href="https://cal.com/shubhendumadhukar">Talk to us</a> about how you can start early testing without waiting for everything to be ready.</strong></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://beltebelt.github.io/norte/tags/javascript/">Javascript</a></li>
      <li><a href="https://beltebelt.github.io/norte/tags/tooling/">Tooling</a></li>
      <li><a href="https://beltebelt.github.io/norte/tags/prototyping/">Prototyping</a></li>
      <li><a href="https://beltebelt.github.io/norte/tags/mocks/">Mocks</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://beltebelt.github.io/norte/">Norte</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
